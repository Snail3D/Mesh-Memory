# MeshTastic Operational Knowledge Base
Curated from Meshtastic's official documentation repository (https://github.com/meshtastic/meshtastic) on demand.
Scope: hardware characteristics, firmware workflows, configuration, integrations, and operational safety.
Usage policy: Treat this as authoritative for field operations. When uncertainty remains, advise the user to consult upstream docs.

## About / Introduction

Meshtastic® is a project that enables you to use inexpensive LoRa radios as a long range off-grid communication platform in areas without existing or reliable communications infrastructure. This project is 100% community driven and open source!
Image: LoRa Topology (/img/introduction/lora-topology-2.webp)
### Features
- Long range (_331km record by MartinR7 & alleg_ (/docs/overview/range-tests#current-ground-record-331km))
- No phone required for mesh communication
- Decentralized communication - no dedicated router required
- Encrypted communication
- Excellent battery life
- Send and receive text messages between members of the mesh
- Optional GPS based location features
- And more!


## How it works
Meshtastic utilizes LoRa, a long-range radio protocol, which is widely accessible in most regions without the need for additional licenses or certifications, unlike ham radio operations.
These radios are designed to rebroadcast messages they receive, forming a mesh network. This setup ensures that every group member, including those at the furthest distance, can receive messages.
Additionally, Meshtastic radios can be paired with a single phone, allowing friends and family to send messages directly to your specific radio. It's important to note that each device is capable of supporting a connection from only one user at a time.
If you are interested in a more technical overview of how Meshtastic works, visit the overview section below: Technical Overview


## Contributors
Meshtastic is an open source project available on GitHub. Our generous volunteers donate their personal time to write and maintain this codebase. If you would like to contribute see our GitHub (https://github.com/meshtastic), participate in the community forums (https://github.com/orgs/meshtastic/discussions). Contribute!


## Start using Meshtastic
Hopefully your "Getting Started" experience is straight forward and headache free. If you encounter any issues, please consider updating our documentation to improve future user experiences or reach out on the community forum.
Our support is 100% volunteer based. We are passionate about the project and hope to help newcomers become Meshtastic experts! Getting Started



## About / Overview / Index


## How it works
When you send a message on your Meshtastic companion app, it is relayed to the radio using Bluetooth, Wi-Fi/Ethernet or serial connection. That message is then broadcasted by the radio. If it hasn't received a confirmation from any other device after a certain timeout, it will retransmit the message up to three times.
When a receiving radio captures a packet, it checks to see if it has heard that message before. If it has it ignores the message. If it hasn't heard the message, it will rebroadcast it.
For each message a radio rebroadcasts, it marks the "hop limit" down by one. When a radio receives a packet with a hop limit of zero, it will not rebroadcast the message.
The radio will store a small amount of packets (around 30) in its memory for when it's not connected to a client app. If it's full, it will replace the oldest packets with newly incoming text messages only.


## What is a mesh?
At the radio level a Meshtastic mesh is a set of nodes that share the same LoRa spreading factor, center frequency, and bandwidth. A node can only be in one radio mesh; it will not see or respond to messages from nodes using different values for these settings. For a mesh to form, nodes need to share the same values.
These values are grouped into "presets" that can be easily chosen in the LoRa configuration section. Presets make it easy for nodes to configure the same radio parameters.
Sitting on top of this radio mesh are Channels. A logical mesh is formed by a Channel with a particular name and encryption key. The default channel in a radio mesh is Channel 0 with a blank "name" and an encryption key of AQ==.
Nodes can belong to a maximum of 8 Channels in the radio mesh. A custom Channel can be created for use by a specific group. Only nodes configured with the same Channel name and encryption key will be able to read and display messages on that Channel. However, all nodes in the radio mesh will receive and may retransmit messages (depending on their Role) regardless of the Channel settings for the message.



## About / Overview / Mesh Alg


## Current Algorithm
The routing protocol for Meshtastic is designed to support all kinds of different use-cases. Most importantly, it does not assume merely static nodes. If you want to test its theoretical performance, you can have a look at the simulator (https://github.com/GUVWAF/Meshtasticator). The protocol is heavily influenced by the mesh routing algorithm used in RadioHead (https://www.airspayce.com/mikem/arduino/RadioHead) (which was used in very early versions of this project). It has four conceptual layers and (since version 2.6) uses a different approach for broadcasts and direct messages.
### A Note About Protocol Buffers
Because we want our devices to work across various vendors and implementations, we use Protocol Buffers (https://github.com/meshtastic/protobufs) pervasively. For purposes of this document you mostly only
need to consider the MeshPacket and Sub-packet message types.
### Layer 0: LoRa Radio
All data is converted into LoRa symbols which are sent to the radio for transmission. The details are described elsewhere, but it is worth noting that in addition to the converted packet bytes described below, there is also a preamble sent at the start of any data packet.
This preamble allows receiving radios to synchronize clocks and start framing. We use a preamble length of 16, which is longer than the minimum preamble length of 8, to let SX126x LoRa receivers sleep for a while, which lowers power consumption.
After the preamble comes the LoRa Physical Header, which contains information about the packet length as well as a sync word to distinguish networks. For Meshtastic, it is set to `0x2B`.
### Layer 1: Unreliable Zero Hop Messaging
This layer is conventional non-reliable LoRa packet transmission. A packet generated by a Meshtastic device has the following representation before encoding for transmission:
| Offset | Length | Type | Usage |
| :----: | :--------------------------------------: | :-----: | :------------------------------------------------------------------------------------------------------ |
| 0x00 | 4 bytes | Integer | Packet Header: Destination. The destination's unique NodeID. `0xFFFFFFFF` for broadcast. Little Endian. |
| 0x04 | 4 bytes | Integer | Packet Header: Sender. The sender's unique NodeID. Little Endian. |
| 0x08 | 4 bytes | Integer | Packet Header: The sending node's unique packet ID for this packet. Little Endian. |
| 0x0C | 1 byte | Bits | Packet Header: Flags. See the header flags (#packet-header-flags) for usage. |
| 0x0D | 1 byte | Bits | Packet Header: Channel hash. Used as hint for decryption for the receiver. |
| 0x0E | 1 byte | Bytes | Packet Header: Next-hop used for relaying. |
| 0x0F | 1 byte | Bytes | Packet Header: Relay node of the current transmission. |
| 0x10 | Max. 237 bytes (excl. protobuf overhead) | Bytes | Actual packet data. Unused bytes are not transmitted. |
#### Packet Header Flags
| Index | # of Bits | Usage |
| :---: | :-------: | :----------------------------- |
| 0 | 3 | HopLimit (see note in Layer 3) |
| 3 | 1 | WantAck |
| 4 | 1 | ViaMQTT (packet came via MQTT) |
| 5 | 3 | HopStart (original HopLimit) |
#### Usage Details
- **Packet Header:** is described directly by the `PacketHeader` class in the C++ source code. But indirectly it matches the first portion of the `MeshPacket` protobuf definition. Note that the packet header is not encoded using a protobuf, but is sent as raw bytes. This both saves airtime and allows receiving radio hardware to optionally filter packets before waking the main CPU.
- **Packet Header - NodeIDs:** are constructed from the bottom four bytes of the MAC address of the Bluetooth address. Because the OUI is assigned by the IEEE, and we currently only support a few CPU manufacturers, the upper byte is de-facto guaranteed unique for each vendor. The bottom 3 bytes are guaranteed unique by that vendor.
- **Packet Header - Unique ID:** The ID is a large, 32 bit ID to ensure there is enough unique state to protect an encrypted payload from attack.
- **Payload:** An encrypted and packed protobuf encoding of the SubPacket protobuf. Only the SubPacket is encrypted, while headers are not. This allows the option of eventually allowing nodes to route packets without knowing anything about the encrypted payload. For more information, see the encryption (/docs/overview/encryption) and Protobuf API Reference (https://buf.build/meshtastic/protobufs/). Any data past the maximum length is truncated.
#### Carrier-Sense Multiple Access with Collision Avoidance (CSMA/CA)
Meshtastic adopts CSMA/CA, similar as to what is used in WiFi. This means that all transmitters must perform Channel Activity Detection (CAD) before attempting to transmit. If the channel is considered busy, the node will wait until it is not anymore. Since once the channel becomes idle multiple nodes might want to start transmitting, a node has to wait a random multiple of slot times. The slot time is the time needed to reliably perform CAD. The amount of slot times to wait is randomly picked from a contention window (CW), which size depends on the current channel utilization. The contention window is larger for a higher channel utilization, in order to limit the chance of collisions.
### Layer 2: Reliable Zero Hop Messaging
... (section truncated for brevity)

## Broadcasts using Managed Flooding
Given the various use-cases and scenarios Meshtastic supports, most of our protocol is built around flooding ( ), meaning that every node rebroadcasts a packet it receives, up till a certain hop limit. However, an important difference in Meshtastic is that before rebroadcasting, a node listens a short while to see if another node has already rebroadcasted the packet. If so, it will not rebroadcast. "Managed Flooding" is therefore a better term.
The principle is as follows. If any mesh node sees a packet with a HopLimit other than zero, it will decrement that HopLimit and attempt to rebroadcast on behalf of the original sending node. In order to promote letting nodes that are further away flood the message, such that the message eventually reaches farther, the contention window (see Layer 1) for a flooding message depends on the Signal-to-Noise Ratio (SNR) of the received packet. The CW size is small for a low SNR, such that nodes that are further away are more likely to flood first and closer nodes that hear this will refrain from flooding. An exception to this rule is for the `ROUTER` and `REPEATER` roles, that have a higher priority to rebroadcast and will do so even if they hear another node rebroadcasting.
### Example
Below you see an example topology consisting of four nodes in `CLIENT` mode, where at a certain point node 0 wants to send a broadcast message.
Due to limited coverage, it only reaches nodes 1 and 2. Since node 2 is farther away, its SNR is lower and therefore starts rebroadcasting earlier than 1.
After node 0 received this rebroadcast, its message is acknowledged. Note that a message is already acknowledged once a rebroadcast from any Meshtastic node (whether or not it has the same encryption key) is received.
Since node 1 heard the rebroadcast by 2, it will not rebroadcast again. Node 3 heard the message for the first time and the HopLimit is not yet zero, so it starts a rebroadcast for potential other receivers.
Image: Mesh algorithm example (/img/SNR_based_flooding.webp)


## Direct messages using Next-Hop routing
Since version 2.6, Meshtastic uses a different approach for direct messages. Initially, the managed flooding approach as mentioned before is used to reach the destination.
We'll then keep track of the node(s) that are trying to relay the packet for us. If upon a successful delivery, a response comes back (e.g., a NodeInfo response, acknowledgment or traceroute) and the node that relays this towards you was also (one of) the node(s) that relayed the original packet, it will be denoted as next-hop from now on. This means that instead of letting all nodes try to relay the packet, only the node for which the next-hop byte matches will. Note that this is determined per hop, so if there is an asymmetric link or a node on older firmware in between, managed flooding will be used on this hop. When a node moves, or RF conditions change, it might be the next-hop is not valid anymore. Therefore, a node will always fall back to managed flooding at the last retransmission attempt if it doesn't hear its next-hop relay.
The procedure is visualized in the following diagram:
Image: Next-Hop Routing procedure (/img/blog/NextHopRouting.webp)
### Regular Broadcast Intervals
Without additional modules configured, nodes will produce three different types of regularly intervaled traffic as part of the mesh:
1. Device Telemetry - Controlled by `telemetry.device_update_interval` - Default: 30 minutes
2. Position - Controlled by `position.position_broadcast_secs` - Default: 15 minutes\* (with smart broadcast (/docs/configuration/radio/position/#smart-broadcast) enabled)
3. NodeInfo user - Controlled by `device.node_info_broadcast_secs` - Default: 3 hours
As meshes grow larger and traffic becomes more contentious, the firmware will increase these intervals. This is in addition to duty cycle, channel, and air-time utilization throttling.
Starting with version 2.4.0, the firmware will scale back Telemetry, Position, and other ancillary port traffic for meshes larger than 40 nodes (nodes seen in the past 2 hours) using the following algorithm:
`ScaledInterval = Interval * (1.0 + ((NumberOfOnlineNodes - 40) * 0.075))`
For example an active mesh of 62 nodes would scale back `telemetry.device_update_interval` to 79.5 minutes instead of the 30 minute default.



## About / Overview / Radio Settings

Meshtastic is **not** LoRaWAN, Helium or TTN (TheThingsNetwork). Meshtastic uses the full spectrum frequency range designated to LoRa technology per region. This allows for several hundred possible frequency channels in the US region alone.
Power limits will generally be lifted in the software if `is_licensed` is set to `true`. See Ham Mode (/docs/faq#amateur-radio-ham) for more information. ## Frequency Slot Calculator


## Europe Frequency Bands
EU countries will generally be covered by the Radio Equipment Directive (2014/53/EU (http://data.europa.eu/eli/dir/2014/53/2023-10-01)) and subsequent amendments, which is then enacted in local laws. Useful information on this is located here (https://single-market-economy.ec.europa.eu/single-market/european-standards/harmonised-standards/radio-equipment_en).
The bands below were selected based on the maximum power and the duty cycle available. It may be possible to use other frequency bands for specific applications, but these are not currently supported "out of the box".
### 433 MHz
The maximum power allowed for Europe is +10 dBm ERP (Effective Radiated Power (https://en.wikipedia.org/wiki/Effective_radiated_power)).
The band range is from 433 to 434 MHz.
There are four frequency slots defined with the standard radio preset `LongFast`. After factory reset the radio will be set to frequency slot 4 with a center frequency of 433.875 MHz.
### 868 MHz
The maximum power allowed for Europe is +27 dBm ERP (Effective Radiated Power (https://en.wikipedia.org/wiki/Effective_radiated_power)).
The band range is from 869.40 to 869.65 MHz. This is less than the 863–870 MHz range defined as SRD (Short Range Devices (https://www.etsi.org/technologies/short-range-devices)) Band, but allows for a higher ERP and a duty cycle of 10%.
There is one frequency slot defined with the standard radio preset `LongFast`. After factory reset the radio will be set to frequency slot 1 with a center frequency of 869.525 MHz.
It is worth noting that 868 MHz is generally the most popular frequency band for Meshtastic in Europe.


## North America Frequency Bands
### 915 MHz (ISM Band)
The maximum output power for North America is +30 dBm ERP (Effective Radiated Power (https://en.wikipedia.org/wiki/Effective_radiated_power)).
The band range is from 902 to 928 MHz.
In North America, the available Frequency Slots depend on the bandwidth setting, which is included in the selected Radio Preset. The standard Preset, LongFast, provides 104 Frequency Slots. After a factory reset, the radio defaults to LongFast with a Frequency Slot of 0, which translates to Slot 20 (centered at 906.875 MHz) based on the channel hashing algorithm.


## Data Rates
### Considerations
Various data-rate options are available when configuring a frequency slot and are inversely proportional to the theoretical range of the devices.
- **Spreading Factor (SF)** - How much we "spread" our data over time. - Each step up in Spreading Factor doubles the airtime to transmit. - Each step up in Spreading Factor adds about 2.5db extra link budget.
- **Bandwidth** - How big of a slice of the spectrum we use. - Each doubling of the bandwidth is almost 3db less link budget. - Bandwidths less than 31 may be unstable unless you have a high quality Crystal Oscillator.
- **Coding Rate** - How much redundancy we encode to resist noise. - Increasing coding rate increases reliability while decreasing data-rate. - 4/5 - 1.25x overhead - 4/6 - 1.5x overhead - 4/7 - 1.75x overhead - 4/8 - 2x overhead
### Presets
We have eight LoRa radio presets. These are the most common settings and have been proven to work well:
| Radio Preset | Alt Preset Name | Data-Rate | SF / Symbols | Coding Rate | Bandwidth | Link Budget |
| :--------------------: | :--------------: | :--------: | :----------: | :---------: | :----------: | :---------: |
| Short Range / Turbo | Short Turbo | 21.88 kbps | 7 / 128 | 4/5 | 500 kHz[^1] | 140dB |
| Short Range / Fast | Short Fast | 10.94 kbps | 7 / 128 | 4/5 | 250 kHz | 143dB |
| Short Range / Slow | Short Slow | 6.25 kbps | 8 / 256 | 4/5 | 250 kHz | 145.5dB |
| Medium Range / Fast | Medium Fast | 3.52 kbps | 9 / 512 | 4/5 | 250 kHz | 148dB |
| Medium Range / Slow | Medium Slow | 1.95 kbps | 10 / 1024 | 4/5 | 250 kHz | 150.5dB |
| Long Range / Fast | Long Fast | 1.07 kbps | 11 / 2048 | 4/5 | 250 kHz | 153dB |
| Long Range / Moderate | Long Moderate | 0.34 kbps | 11 / 2048 | 4/8 | 125 kHz | 156dB |
| Long Range / Slow | Long Slow | 0.18 kbps | 12 / 4096 | 4/8 | 125 kHz | 158.5dB |
The link budget used by these calculations assumes a transmit power of 22dBm and an antenna with 0dB gain. Adjust your link budget assumptions based on your actual devices. Data-rate in this table is the theoretical max but doesn't account for packet headers, hops and re-transmissions. Calculations based on data from the official Semtech LoRa calculator (https://www.semtech.com/design-support/lora-calculator).
Image: link budget vs data rate plot (/img/about/link-budget-vs-data-rate.webp)
### Custom Settings
Custom settings can be applied by using supported software (/docs/software).
After applying the settings, you will need to restart the device. After your device is restarted, it will generate a new crypto key and you will need to share the newly generated QR[^2] Code or URL to all your other devices.
[^2]:
Some example settings:
| Data-rate | SF / Symbols | Coding Rate | Bandwidth | Link Budget | Note |
| :--------: | :----------: | :---------: | :-------: | :---------: | :----------------------------------------------------------------------- |
| 37.50 kbps | 6 / 64 | 4/5 | 500 kHz | 129dB | Fastest possible speed |
| 3.125 kbps | 8 / 256 | 4/5 | 125 kHz | 143dB | |
| 1.953 kbps | 8 / 256 | 4/8 | 125 kHz | 143dB | |
| 1.343 kbps | 11 / 2048 | 4/8 | 500 kHz | 145dB | |
| 1.099 kbps | 9 / 512 | 4/8 | 125 kHz | 146dB | |
| 0.814 kbps | 10 / 1024 | 4/6 | 125 kHz | 149dB | |
| 0.610 kbps | 10 / 1024 | 4/8 | 125 kHz | 149dB | |
| 0.488 kbps | 11 / 2048 | 4/6 | 125 kHz | 152dB | |
| 0.073 kbps | 12 / 4096 | 4/5 | 31 kHz | 160dB | Twice the range and/or coverage of "Long Slow", low resilience to noise |
... (section truncated for brevity)

## Cryptography
The pre-shared key (PSK) used by the devices can be an AES128 or AES256 sequence. Alternatively, encryption can be turned off, which may be useful if you are operating under a ham radio license.
[^1]: Short Turbo is the fastest preset and the only one with 500kHz bandwidth. It is not legal to use in all regions due to this wider bandwidth.



## About / Overview / Encryption / Index


## Explanation
Meshtastic provides AES256-CTR encryption for the payload of each packet when sending via LoRa, with a different key for each channel (/docs/configuration/radio/channels/). The packet header (/docs/overview/mesh-algo/#layer-1-unreliable-zero-hop-messaging) is always sent unencrypted, which allows nodes to relay packets they can't decrypt as well. One can disable this by setting a different rebroadcast mode (/docs/configuration/radio/device#rebroadcast-mode).
By default, you have one primary channel, which is encrypted with a simple known key ("AQ=="), so to use proper encryption, you **must change** this key first, or create a new channel and share it with the ones you want to communicate with. However, without a channel using the default key, communication with devices still using it will not be possible.
Direct messages to a specific node are now encrypted using Public Key Cryptography (PKC). Each node is equipped with a unique public/private key pair, and direct messages are encrypted with the recipient's public key. This ensures that only the recipient can decrypt the message using their private key. Additionally, messages are signed with the sender's private key, allowing the recipient to verify the sender's identity and ensuring the message's integrity.
All periodic broadcasts (position, telemetry, traceroutes, etc.) the device sends out itself are sent over the primary channel and thus encrypted with that key.
The device will decrypt the payload before sending it to a client app via BLE, serial, Wi-Fi/Ethernet. For MQTT, you can specify (/docs/configuration/module/mqtt#encryption-enabled) whether you want to send an encrypted or unencrypted payload.


## Is it as secure as Wi-Fi WPA3, HTTPS TLS1.3, or Signal?
**No**.
WPA3 (https://en.wikipedia.org/wiki/WPA3), TLS1.3 (https://en.wikipedia.org/wiki/TLS1.3), Signal (https://en.wikipedia.org/wiki/Signal_Protocol), and Meshtastic can all use AES256. Yet AES is one of the many cogs required in a modern encryption system. Below are the main features "missing" in Meshtastic.
### Perfect-Forward-Secrecy
**P**erfect-**F**orward-**S**ecrecy, also known as **PFS** (https://en.wikipedia.org/wiki/Forward_secrecy), means _previous_ communications and more generally anything _passively captured_ cannot be decrypted **_even when the key is compromised_**.
This means Meshtastic is vulnerable to **« Harvest now, Decrypt later »** (https://en.wikipedia.org/wiki/Harvest_now,_decrypt_later) attacks. **This attack itself is not enough to decrypt messages**; it relies on another failure leaking the channel key, such as:
- Accidentally sharing the channel key with the wrong person.
- One of your nodes being stolen.
- Any unknown bug revealing the channel key to an attacker.
Other protocols, such as _misconfigured TLS1.2_, are far more impacted by Harvest now, Decrypt later attacks because their keys will be broken by near-future Quantum-Computers, yet they do not provide PFS either.
Meshtastic's AES256 encryption is considered quantum-resistant[^1], but the public/private key exchange for DMs is not, as current quantum-resistant cryptography schemes don't fit in LoRa packets or our IoT hardware; realistic attack vectors include accidental mishandling of channel keys, nodes being lost, and potential future quantum attacks on DM key exchanges.
[^1]: On the Quantum-Resistance of AES256, see this stackoverflow question, containing a bit of debate and two good answers (https://crypto.stackexchange.com/q/6712) and the NIST's Post-Quantum FAQ (https://csrc.nist.gov/projects/post-quantum-cryptography/faqs) section "To protect against the threat of quantum computers, should we double the key length for AES now? (added 11/18/18)"
#### Recommendations for users using private channels
- **Do not configure private channels on unattended nodes**. Nodes will relay Meshtastic traffic even if they are not able to decrypt it. Your unattended routers should not have the private PSK configured as it is easy to gain physical access and extract the channel key.
- Keep in mind that everything sent on a channel can be stored and decrypted later by anyone who gains access to the key, even if you locally delete the messages.
- Change your Channel Keys from time to time.
#### Changes since 2.5.0 Firmware release
- Direct Messages are now protected with PKC when messaging between devices on v2.5.0 or newer and key exchange has taken place, messaging to legacy 2.4.3 or older firmware versions are not protected.
- Admin Messages between two v2.5.0 or newer nodes are now protected and additional relay attack protection is in place.
### Integrity
Integrity means ensuring messages cannot be modified without the key.
Meshtastic does not verify the integrity of channel messages to check if they have been tampered with (see issue #4030 (https://github.com/meshtastic/firmware/issues/4030) for details).
#### Recommendations
- Keep in mind that by applying a known plaintext attack, anyone _could_ send messages on a channel even if the channel key is private and secure.
- For developers of third-party applications integrating Meshtastic, include a cryptographic MAC over the message content and PSK. We are also considering an AEAD secured channel mode which would provide this natively (https://github.com/meshtastic/firmware/issues/4030).
#### Changes since 2.5.0 Firmware release
- Message integrity is checked for Direct Messages or Admin Control when communication is between v2.5.0 or newer firmware.
### Authentication
Authentication means nodes say who they are on the network. Meshtastic does not implement this, so it is trivial to impersonate anyone else if you have access to the channel key
This is because node IDs are based on hardware MAC address (https://en.wikipedia.org/wiki/MAC_address), which are hardcoded by the manufacturer.
Some other networks like Yggdrasil (https://yggdrasil-network.github.io/), cjdns (https://github.com/cjdelisle/cjdns), or libp2p (https://libp2p.io/) use public/private key pairs (https://en.wikipedia.org/wiki/Public-key_cryptography), and the Public Key becomes the Node Identity. This makes all messages bigger and/or requires an interactive handshake process.
#### Recommendations
- Keep in mind that the sender field is indicative, and anyone with access to the channel key can trivially lie.
#### Changes since 2.5.0 Firmware release
- The above now only relates to group chats/channels as DM's are protected when messaging between devices on 2.5 or newer, messaging to legacy 2.4 or older devices are not afforded this addition authentication.


## Direct Messages
Direct Messages (DMs) are now implemented using Public Key Cryptography (PKC). This provides a significant upgrade in security compared to the previous channel-based encryption:
- **Message Encryption:** Each DM is encrypted using the recipient's public key, ensuring that only the recipient can decrypt the message with their private key.
- **Digital Signatures:** Messages are signed with the sender's private key, allowing the recipient to verify the sender's identity and ensuring the integrity of the message.
### Prior to 2.5.0 Firmware Release
Previously, DMs were implemented as channel messages with a `to` protobuf field set. This meant anyone in the channel could read all your direct messages. With PKC, this issue is resolved, as only the intended recipient can decrypt and read the message.
### Recommendations
- While PKC significantly enhances the security of DMs, it's still advisable to avoid sharing sensitive information in direct messages without proper verification of the recipient's public key.


## Admin Messages
Admin Messages/Control are now protected by enhanced security features, making sure that critical operations within the network are more secure than ever before.
- **Stronger Encryption:** Admin Messages now use advanced encryption methods to ensure that only the intended recipients can access and read them.
- **Session IDs:** Each administrative session is assigned a unique Session ID, which helps prevent unauthorized access and ensures that messages are not tampered with or replayed.
### Prior to 2.5.0 Firmware Release
Previously, admin messages were not as secure, but with these updates, they are now much better protected against potential attacks and replay attacks.
### Recommendations
- Always ensure that your devices are using the latest firmware to benefit from these improved security features.
- Regularly monitor your network for any unusual activity to maintain a high level of security.



## About / Overview / Encryption / Limitations

Meshtastic’s security model sits at the intersection of multiple conflicting requirements. This document explains the requirements, the tradeoffs they represent, and characterizes the current limitations chosen to make Meshtastic usable. It also covers recent changes and upcoming fixes.
This information is not new, but until now was spread through community discussions, GitHub issues, and comments in the Meshtastic codebase. This document is an effort to plainly lay it out in one place.


## Limitations
This system, by necessity, uses a Trust On First Use (TOFU) model. There is no central authority to sign user keys, and so nodes will store and retain the first public key announced for a given node number. This is essentially a hard requirement of a decentralized mesh network.
This issue is compounded by the limited memory for storing nodes on a Meshtastic node. The NodeDB is limited to 100 nodes on most hardware, and when more Nodes are seen on a network, the oldest and least interesting node rolls off the NodeDB to make room for new nodes. The exception to this is that favorited nodes are guaranteed not to be removed from the NodeDB.
The combination of the TOFU model and constrained hardware leads to a problem. When a node rolls off the NodeDB, the Meshtastic firmware has no way to confirm that a future User packet isn’t a spoof of that Node Number, with a different public key. This problem is made worse by the possibility that an attacker on the channel can quickly create fake nodes, and cause legitimate nodes to roll off the NodeDB sooner.
This attack was anticipated when the DM system was designed, and accepted as an inevitable result of building an ad-hoc, decentralized mesh. Again, there is no central authority to sign keys. As a result, multiple mitigations were built in to the system to minimize the actual usefulness of this attack.


## Intended Behavior
First, while the NodeDB is limited to 100 nodes on embedded hardware, a connected mobile client has the ability to store information about many more nodes, and flag to the user when one of those nodes shows up with a different public key. This is what happens when a node on a client shows up with a red key icon. The firmware has seen a different public key for that node, and the mobile client knows that it has changed.
The second major mitigation is that nodes that are marked as favorite are never dropped from the NodeDB. Clients have now automatically mark nodes as favorite when a DM is sent to that node, further ensuring that the node a user was chatting with is still the same node.
The meshtastic firmware does also support falling back to the old DM behavior. This is tightly controlled via the use of the “pki_encrypted” boolean and the “public_key” byte field. When the firmware receives a packet from the mesh, if that packet is sent using the DM PKI encryption, the bool is marked true, and the source public key is copied into the bytes field. DMs using the old channel PSK method will still be received and processed, but the pki_encrypted field is set false.
Packets sent from a connected client may set the “pki_encrpyted” boolean to true, and populate the public_key byte field on a packet sent through the local API. If the boolean is set to true, then the packet will only be sent via a PKI DM. If the bytes are populated, the packet will only be sent if the public key in the API message matches the public key for that node in the local NodeDB. If the boolean is not set to true, the firmware will send the packet as a PKI DM if it is indeed sent to a single target, and the firmware has a public key for that target. Outgoing messages will fall back to using the less secure channel encryption if no public key is known for the remote node and the pki_encrypted bool is unset


## The ED25519 Future
A few weaknesses of the Meshtastic system can be addressed by adding a message signing system to channel messages. As we still have limited NodeDB storage space and LoRa packets are still limited to 256 byte maximum size, it’s a virtual requirement that this signing system reuse the existing public/private key pairs, and the signatures be as small as possible.
There has been an additional suggestion repeatedly made, that the nodeNum should be derived from the publicKey, to minimize the ability of an attacker to spoof a User packet from an existing nodenum with a new public key. While the Meshtastic security team has generally agreed with the wisdom of this suggestion, it has been impractical to implement as a breaking change to the mesh. The addition of signed messages actually presents an opportunity to enforce this new nodenum source, while still remaining backwards compatible with the older system.
The ED25519 support is still being finalized as of the writing of this document, but the current prototype code uses the XEdDSA system from Signal to take existing X25519 signatures and re-use them as ED25519 signatures. While this does significantly improve the security assurances of the Meshtastic system, these signatures are 64 bytes long, which is significant given the LoRa message size.
Once a node has successfully signed a User message with this scheme, the HAS_XEDDSA_SIGNED bit is set on the NodeInfoLite bitfield, which is translated to the has_xeddsa_signed bool on a NodeInfo message.
Once this bit is set, unsigned user packets from this source will be dropped. To be determined is how other unsigned packets will be treated. At this point, the recommendation is that short packets, that could be signed, should be dropped when unsigned.



## Getting Started / Index


## Identify Hardware
This guide assumes that you have already purchased the devices you will be using with Meshtastic. If you haven't, you can check out our list of supported hardware (/docs/hardware/devices/index.mdx)
to see your options.
Before you begin, it's important to determine which kind of hardware you're using. Meshtastic works with devices that have these types of Micro-Controller Units (MCU):
### ESP32
The ESP32 chip is older and consumes more power than the nRF52 chip, but is equipped with both WiFi and Bluetooth. Supported ESP32 devices include:
- LILYGO® TTGO T-Beam (>V1.1 recommended)
- LILYGO® TTGO Lora (>V2.1 recommended)
- Nano G1
- Station G1
- Heltec V3 and Wireless Stick Lite V3
- RAK11200 Core module for RAK WisBlock modular boards
### nRF52
The nRF52 chip is much more power efficient than the ESP32 chip and easier to update, but is only equipped with Bluetooth. Supported nRF52 devices include:
- RAK4631 Core module for RAK WisBlock modular boards
- LILYGO® TTGO T-Echo
### RP2040
The RP2040 is a dual-core ARM chip developed by Raspberry Pi. Supported RP2040 devices include: - Raspberry Pi Pico + Waveshare LoRa Module (Note: **Bluetooth on the Pico W is not yet supported by Meshtastic**) - RAK11310 Core module for RAK WisBlock modular boards
If your device is not listed above, please review our supported devices (/docs/hardware/devices/index.mdx) to determine which MCU your device has or contact the community via the forum (https://github.com/orgs/meshtastic/discussions) with any questions.
Never power on the radio without attaching an antenna as doing so could damage the radio chip!
Prior to connecting your Meshtastic device to the computer, you should perform the following basic checks.
### Verify Data Cable
Some cables only provide _charging_, verify that your cable is also capable of _transferring data_ before proceeding. To check if your cable can also transfer data, try connecting it to another device (like a phone) and see if you can copy a file to or from it. If the file transfer works, then your cable is also able to transfer data and you can continue.
### Install Serial Drivers
nRF52/RP2040 devices typically do not require serial drivers. They use the UF2 bootloader which makes the devices appear as flash drives. Do _NOT_ download the USB device drivers unless required to install UF2 support.
If you require serial drivers installed on your computer, please choose one of the options below and install it before continuing. Install ESP32 Drivers Install nRF52/RP2040 Drivers
### Flash Firmware
After completing the previous steps, you can now flash the Meshtastic firmware onto your device. To proceed, select the appropriate device type for your device. Flash ESP32 Firmware Flash nRF52/RP2040 Firmware
### Connect and Configure Device
After flashing the Meshtastic firmware onto your device, you can now move on to initial configuration. Connect and Configure Device



## Getting Started / Initial Config


## Set Regional Settings
In order to start communicating over the mesh, you must set your region. This setting controls which frequency range your device uses and should be set according to your regional location. Android ), value: "android", }, { label: ( <> Apple ), value: "apple", }, { label: ( <> CLI ), value: "cli", }, { label: ( <> Web ), value: "web", }, ]}>
#### Android
1. Follow the installation (/docs/software/android/installation) and usage (/docs/software/android/usage/) instructions for Meshtastic Android (/docs/category/android-app).
2. Open the app, connect to the device from your phone over USB Serial or Bluetooth.
3. Once paired, Click "UNSET" next to the device name.
4. Select the region from the list according to your regional location.
#### Apple
Configuration of Region, Modem Preset and Hop Limit is available on iOS, iPadOS and macOS at Settings > Radio Configuration > LoRa.
#### CLI
1. Install Meshtastic PythonCLI (/docs/software/python/cli/installation) ```sh pip3 install --upgrade pytap2 pip3 install --upgrade meshtastic ```
2. Run the following command, replacing ` ` with the region code listed above according to your regional location. ```sh meshtastic --set lora.region ```
#### Web
1. Open the Meshtastic Web interface: client.meshtastic.org (https://client.meshtastic.org)
2. Navigate to the **LoRa** menu.
3. Under **Regional Settings**, set your **Region** according to your regional location.
4. Click **Save**.
### Region Codes
Refer to LoRa Region by Country (/docs/configuration/region-by-country) for a more comprehensive list.


## Continue Configuration
Now that you have set the LoRa region on your device, you can continue with configuring any additional configs to suit your needs. Device Configuration



## Flash Firmware
After completing the previous steps, you can now flash the Meshtastic firmware onto your device. To proceed, select the appropriate device type for your device. Flash ESP32 Firmware Flash nRF52/RP2040 Firmware



## Configuration / Radio / Index

There are several config sections in the Meshtastic firmware, these are broken out so they can be sent as small admin messages over the mesh.
| Name | Description |
| :----------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| Bluetooth (./bluetooth) | The bluetooth config options are: Enabled, Pairing Mode and Fixed PIN. |
| Channels (./channels) | The channels config options are: Index, Role and Settings. |
| Device (./device) | The device config options are: Device Role, Serial Output, Debug Log and Factory Reset. |
| Display (./display) | The display config options are: Screen On Duration, Auto Carousel Interval, Always Point North, and GPS Format. |
| LoRa (./lora) | The LoRa config options are: Region, Modem Preset, Max Hops, Transmit Power, Bandwidth, Spread Factor, Coding Rate, Frequency Offset, Transmit Disabled and Ignore Incoming Array. |
| Network (./network) | The network config options are: WiFi Enabled, WiFi SSID, WiFi PSK, WiFi Mode and NTP Server. |
| Position (./position) | The position config options are: GPS Enabled, GPS Update Interval, GPS Attempt Time, Fixed Position, Smart Broadcast, Broadcast Interval and Position Packet Flags. |
| Power (./power) | The power config options are: Charge Current, Power Saving, Shutdown after losing power, ADC Multiplier Override Wait Bluetooth Interval, Light Sleep Interval and Minimum Wake Interval. |
| Security (./security) | The security config options are: Public Key, Private Key, Admin Key, Is Managed, Serial Console, Debug Logs, and Admin Channel. |
| User (./user) | The user config options are: Long Name, Short Name, and Is Licensed |



## Configuration / Radio / Channels

The Channels config options are: Index, Roles, and Settings. Channel config uses an admin message sending a `Channel` protobuf which also consists of a `ChannelSettings` or `ModuleSettings` protobuf.
**Channel Settings** (as described on this page) should not be confused with Modem Preset Settings (/docs/configuration/radio/lora#modem-preset)
Modem Preset Settings (/docs/configuration/radio/lora#modem-preset) contain the modem configuration (frequency settings, spreading factor, bandwidth, etc.) used for the LoRa radio. These settings are identical for all channels and can **not** be unique per channel.
**Channel Settings** contain information for segregating message groups, configuring optional encryption, and enabling or disabling messaging over internet gateways. These settings **are** unique and configurable per channel.


## Channel Config Values
### Index
The channel index begins at 0 and ends at 7.
_Indexing_ can not be modified.
| Index | Channel | Default Role | Purpose |
| :---: | :-----: | :----------: | :-----------------------: |
| 0 | 1 | `PRIMARY` | Used as `default` channel |
| 1 | 2 | `DISABLED` | User defined |
| 2 | 3 | `DISABLED` | User defined |
| 3 | 4 | `DISABLED` | User defined |
| 4 | 5 | `DISABLED` | User defined |
| 5 | 6 | `DISABLED` | User defined |
| 6 | 7 | `DISABLED` | User defined |
| 7 | 8 | `DISABLED` | User defined |
You can **not** have `DISABLED` channels in-between active channels such as `PRIMARY` and `SECONDARY`. Active channels must be consecutive.
### Role
Each channel is assigned one of 3 roles:
1. `PRIMARY` or `1` - This is the first channel that is created for you on initial setup. - Only one primary channel can exist and can not be disabled. - Periodic broadcasts like position and telemetry are only sent over this channel.
2. `SECONDARY` or `2` - Can modify the encryption key (PSK).
3. `DISABLED` or `0` - The channel is no longer available for use. - The channel settings are set to default.
While you can have a different PRIMARY channel and communicate over SECONDARY channels with the same Name & PSK, a hash of the PRIMARY channel's name sets the LoRa frequency slot, which determines the actual frequency you are transmitting on in the band.
To ensure devices with different PRIMARY channel name transmit on the same frequency, you must explicitly set the LoRa frequency slot.


## Channel Settings Values
The Channel Settings options are: Name, PSK, Downlink Enabled, and Uplink Enabled. Channel settings are embedded in the `Channel` protobuf as a `ChannelSettings` protobuf and sent as an admin message.
### Name
A short identifier for the channel. _(
The client applications have implemented different levels of precision giving the user a practical range to choose from. Setting across the full range of integers can be done via the Python CLI. See Setting Position Precision (/docs/configuration/radio/channels/#setting-position-precision) for examples on setting different levels of precision using CLI.


## Configuration / Radio / Security

The security config options are: Public Key, Private Key, Admin Key, Is Managed, Serial Console, Debug Logs, and Admin Channel.


## Security Config Values
### Public Key
Acceptable values: `bytes`
The public key of the device, shared with other nodes on the mesh to allow them to compute a shared secret key for secure communication.
### Private Key
Acceptable values: `bytes`
The private key of the device, used to create a shared key with a remote device for secure communication.**This key should be kept confidential.**
### Admin Key
Acceptable values: `repeated bytes`
The public key(s) authorized to send administrative messages to this node. Only messages signed by these keys will be accepted for administrative control.
### Managed Mode
Acceptable values: `true` or `false`
Enabling Managed Mode blocks client applications from writing configurations to a radio(they may be read). Once enabled, radio configurations can only be changed through PKC Remote Admin messages with firmware version 2.5+ or the legacy Admin channel with firmware prior to version 2.5. This setting is **not** required for remote node administration.
Before enabling Managed Mode, verify that the node can be controlled via Remote Admin or legacy Admin channel, and that all functions are working properly to prevent being locked out.
### Serial Console
Acceptable values: `true` or `false`
Disabling this will prevent the Serial Console from initializing the Stream API.
### Debug Log
Acceptable values: `true` or `false`
By default, logging is disabled when an API client connects to keep the shared serial link quiet. Set this to true to continue outputting live debug logs over serial or Bluetooth when the API is active.
### Admin Channel Enabled
Acceptable values: `true` or `false`
Allows incoming device control over the insecure legacy admin channel. Enabling this option permits control messages to be received through the older, less secure admin channel.


## Security Keys - Backup and Restore
### Backup
Public and private keys will be lost and regenerated by performing a firmware erase and reinstall. It is your responsibility to back up your keys to maintain encrypted direct messaging with existing nodes on your mesh.
Suggested backup methods:
- With the Meshtastic CLI (/docs/software/python/cli/), run: `meshtastic --export-config > config_backup.yaml` - this will save your entire configuration including your public and private keys to a file.
- Copy the keys to a secure location, such as a password protected note.
- Take a screenshot - the most basic way, you must ensure you saved the entirety of both keys.
### Restore
To restore your keys you may:
- Use the Meshtastic CLI to run `meshtastic --configure config_backup.yaml` - This is the fastest way to get your entire node back to where you left it!
- Manually paste or retype the keys into the client app from your saved location.



## Configuration / Radio / Network

The Network config options are: NTP Server, WiFi Enabled, WiFi SSID, WiFi PSK, Ethernet Enabled, IPv4 Networking Mode, Static Address rsyslog Server, and Protocol Flags. Network config uses an admin message sending a `Config.Network` protobuf.
Enabling WiFi will disable Bluetooth. Only one connection method will work at a time.
ESP32 devices have the ability to connect to WiFi as a client. SoftAP mode is not supported by the Meshtastic firmware.


## Network Config Values
### NTP Server
The NTP server used if IP networking is available.
Set to `meshtastic.pool.ntp.org` by default. (Max Length: 32)
### WiFi Enabled
Enables or Disables WiFi.
Set to `false` (Disabled) by default.
### WiFi SSID
This is your WiFi Network's SSID.
Empty `""` by default. (Case Sensitive, Max Length: 32)
### WiFi PSK
This is your WiFi Network's password.
Empty `""` by default. (Case Sensitive, Max Length: 64)
### Ethernet Enabled
Enables or Disables Ethernet.
Set to `false` (Disabled) by default.
### IPv4 Networking Mode
Set to `DHCP` by default. Change to `STATIC` to use a static IP address. Applies to both Ethernet and WiFi.
### IPv4 Static Address configuration
Contains IP, Gateway, Subnet, and DNS server for a static configuration if selected in Networking Mode.
### Rsyslog Server
To configure an rsyslog Server and Port. Default logging facility is `user`.
### Protocol Flags
Defines which auxiliary network protocols are used to send packets. Values are stored as a bit field of boolean configuration options (bitwise OR of ProtocolFlags).
| Value | Description |
| :-----------: | :--------------------------------------------------------: |
| NO_BROADCAST | Do not broadcast packets over any network protocol |
| UDP_BROADCAST | Enable broadcasting packets via UDP over the local network |
The first time your device restarts after enabling WiFi or Ethernet, it will take an additional 20-30 seconds to boot. This is to generate self-signed SSL keys. The keys will be saved for future reuse.


## Examples
### WiFi Client
With `network.wifi_ssid` & `network.wifi_psk` populated, the device will know to connect to your network. Make sure you are in range of your WiFi and it is a 2.4GHz-only network. If you have a single Meshtastic device on your local network it's easy to connect to your device with DNS `http://meshtastic.local`. If you have multiple Meshtastic devices you will need to connect using their respective IP addresses.
### Disable WiFi
To disable WiFi completely, set `network.wifi_enabled` to `false`.



## Configuration / Radio / Power

Power settings are advanced configuration, most users should choose a role under Device Config (/docs/configuration/radio/device) to manage power for their device and shouldn't ever need to adjust these settings.
The power config options are: Power Saving, Shutdown after losing power, ADC Multiplier Override, Wait Bluetooth Interval, Light Sleep Interval, Minimum Wake Interval, and Device Battery INA2xx Address. Power config uses an admin message sending a `Config.Power` protobuf.


## Power Config Values
### Power Saving
If enabled, modifications to settings can be made by waking the device through pressing the user button, resetting, or through the admin channel (/docs/configuration/remote-admin/) for remote administration.
When activated, this feature disables Bluetooth, Serial, WiFi, and the device's screen to conserve power. This is particularly beneficial for devices relying on low-current power sources, like solar panels. For details on which device roles have this feature enabled by default, please check the Device Config (/docs/configuration/radio/device) section.
### Shutdown after losing power
Automatically shut down a device after a defined time period if power is lost.
Before setting this, ensure your board correctly detects when it is connected to external power (the "🔌" icon in the app). Otherwise, your device could shut down even when power is present.
Many devices detect power status correctly, however for some devices, you will need to modify the ADC Multiplier (below).
### ADC Multiplier Override
Ratio of voltage divider for battery pin e.g. 3.20 (R1=100k, R2=220k)
Overrides the ADC_MULTIPLIER defined in the firmware device variant file for battery voltage calculation.
Should be set to floating point value between 2 and 6
#### Calibration Process (Attribution (https://wiki.uniteng.com/en/meshtastic/nano-g1-explorer#calibration-process))
1. Install the rechargeable battery.
2. Charge the battery until full. Indication of this state may vary depending on device. At this point, the battery voltage should be 4.2V +-1%.
3. Input the "Battery Charge Percent" displayed on the screen or in your connected app into the calculator below.
4. If "Battery Charge Percent" (e.g., B 3.82V 60%) is not displayed on the screen, it means that the default value of "Operative Adc Multiplier" is too high. Lower the "Operative Adc Multiplier" to a smaller number (it is recommended to decrease by 0.1) until the screen displays "Battery Charge Percent". Enter the current "Operative Adc Multiplier" in use into the "Operative Adc Multiplier" field in the calculator. Also, input the "Battery Charge Percent" displayed on the screen into the calculator.
5. Click the "Calculate" button to compute the "Calculated New Operative Adc Multiplier", and set it as the new "Operative Adc Multiplier" for the device. ADC Calculator This calibration method only maps 4.2V to Battery Charge Percent 100%, and does not address the potential non-linearities of the ADC. Battery Charge Percent: Current Adc Multiplier: Calculated New Operative Adc Multiplier: Calculate Default values for ADC Multipliers are: | Device | Default ADC Multiplier | | :-------: | :--------------------: | | chatter2 | 5.0 | | diy | 1.85 | | esp32-s3-pico | 3.1 | | heltec_v1 & heltec_v2 | 3.2 | | heltec_v3 & heltec_wsl_v3 | 4.9 | | heltec_wireless_paper | 2 | | heltec_wireless_tracker 1.0/1.1 | 4.9 | | heltec_T114 | 4.916 | | lora_isp4520 | 1.436 | | m5stack_coreink | 5 | | nano-g1-explorer | 2 | | nano-g2-ultra | 2 | | picomputer-s3 | 3.1 | | rak4631 | 1.73 | | rpipico | 3.1 | | rpipicow | 3.1 | | station-g1 | 6.45 | | station-g2 | 4 | | tlora_v2_1_16 | 2 | | tlora_v2_1_18 | 2.11 | | tlora_t3s3_v1 | 2.11 | | t-deck | 2.11 | | t-echo | 2 |
### Wait Bluetooth Interval
How long to wait before turning off BLE in no Bluetooth states
`0` for default of 1 minute
### Light Sleep Interval
This setting only applies to ESP32-based boards, it will have no effect on nRF52/RP2040 boards.
In light sleep the CPU is suspended, LoRa radio is on, BLE is off and GPS is on
`0` for default of five minutes
### Minimum Wake Interval
While in light sleep when we receive packets on the LoRa radio we will wake and handle them and stay awake in no Bluetooth mode for this interval
`0` for default of 10 seconds
### Device Battery INA2xx Address
If an INA-2XX device is auto-detected on one of the I2C buses at the specified address, it will be used as the authoritative source for reading device battery level voltage. Setting is ignored for devices with PMUs (e.g. T-beams)
I2C addresses are normally represented in hexadecimal and will require conversion to decimal in order to set via Meshtastic clients. For example the I2C address of 0x40 converted to decimal is 64.


## Configuration / Radio / Position

Position data from GPS is provided by either the radio or your paired phone. It is not required to use Meshtastic, but time calculations require at least one device on the mesh to have either a GPS, RTC, or internet connection for NTP.
The position config uses an admin message to send a `Config.Position` protobuf. The position config options are: GPS Mode, GPS Update Interval, Fixed Position, Smart Broadcast, Smart Broadcast Minimum Distance, Smart Broadcast Minimum Interval, Broadcast Interval, Position Packet Flags, and GPS RX/TX/EN Pins.


## Position Config Values
### GPS Mode
Configures whether the GPS functionality is enabled, disabled, or not present on the node.
Acceptable values: `DISABLED`, `ENABLED`, and `NOT_PRESENT`.
Generally, depending on the device and its configuration, this value will default to either `ENABLED` or `NOT_PRESENT`.
### GPS Update Interval
How often we should try to get GPS position (in seconds), or zero for the default of once every 2 minutes, or a very large value (maxint) to update only once at boot.
### Fixed Position
Acceptable values: `true` or `false`
False by default
If set, this node is at a fixed position. The device will generate GPS updates at the regular GPS update interval, but use whatever the last lat/lon/alt it saved for the node. The lat/lon/alt can be set by an internal GPS or with the help of the mobile device's GPS.
### Smart Broadcast
Acceptable values: `true` or `false`
True by default
Smart broadcast will send out your position at an increased frequency only if your location has changed enough for a position update to be useful.
Smart broadcast complements broadcast interval (doesn't override that setting) but will apply an algorithm to more frequently update your mesh network if you are in motion and then throttle it down when you are standing still. If you use this feature, it's best to leave broadcast interval at the default.
Smart broadcast will calculate an ideal position update interval based on the data rate of your selected channel configuration.
### Smart Broadcast Minimum Distance
Default of `0` is 100 meters
The minimum distance in meters traveled (since the last send) before we can send a position to the mesh if smart broadcast is enabled.
### Smart Broadcast Minimum Interval
Default of `0` is 30 seconds
The minimum number of seconds (since the last send) before we can send a position to the mesh if smart broadcast is enabled.
### Broadcast Interval
Default of `0` is 15 minutes
If smart broadcast is off we should send our position this often.
The GPS updates will be sent out every broadcast interval, either with the actual GPS location or an empty location if no GPS fix was achieved.
### Position Flags
Defines which options are sent in POSITION messages. Values are stored as a bit field of boolean configuration options (bitwise OR of PositionFlags).
| Value | Description |
| :----------------: | :--------------------------------------------------------------: |
| UNSET | Required for compilation |
| ALTITUDE | Include an altitude value (if available) |
| ALTITUDE_MSL | Altitude value is MSL |
| GEOIDAL_SEPARATION | Include geoidal separation |
| DOP | Include the DOP value ; PDOP used by default, see below |
... (section truncated for brevity)

## Configuration / Radio / User

The user config options are: Long Name, Short Name, Is Licensed, and Is Unmessageable. User config uses an admin message sending a `User` protobuf.


## User Config Values
### Long Name
A personalized name for your device.
Auto-generated by default.
If you are a licensed ham operator and have enabled `IsLicensed`, this should be set to your ham operator call sign.
### Short Name
A personalized short identifier for your device.
Auto-generated by default.
### Is Licensed (ham)
If you are a licensed ham operator and have considered the privileges and restrictions (/docs/faq/#amateur-radio-ham) of using Meshtastic with a ham license, enable this flag.
Disabled by default.
By enabling `IsLicensed`, you should also review the following related configurations:
- **User:** `LongName` (Should be your Call Sign)
- **Channel:** `PSK` (Should be Empty, removing encryption)
### Is Unmessageable
Whether or not the node can be direct messaged
Default is False except for roles that typically would not be monitored for direct messages: ROUTER, ROUTER_LATE, REPEATER, SENSOR, LOST_AND_FOUND, TRACKER, TAK_TRACKER


## Configuration / Tips


## Roles
It is strongly recommended to keep your ROLE (/docs/configuration/radio/device#roles) set to `CLIENT`, `CLIENT_MUTE`, or `CLIENT_BASE`. Only use other roles if you have a specific, well-understood reason to do so. Read our blog post about choosing the best role (/blog/choosing-the-right-device-role/).
### Recommended Roles
- `CLIENT` nodes receive, send, and intelligently repeat messages to help the mesh network. - **This is the right choice for most situations.** - Automatically adds smart delays when rebroadcasting to keep the network stable. - Perfect for nodes that can help others: rooftop installations, high-visibility locations, or nodes that extend network coverage. - Use when in remote areas (hiking, skiing, biking) where every node helps maintain connectivity.
- `CLIENT_MUTE` nodes can send and receive messages but never repeat them. - Use with a personal handheld device when located near a more powerful node (such as a rooftop node) in a congested network. - Use when multiple nodes are in close proximity. Set the best-positioned node to `CLIENT` and the others to `CLIENT_MUTE`. - Perfect for indoor nodes that only talk to one outdoor node - since they can't reach other nodes anyway, repeating messages would just waste bandwidth.
- `CLIENT_BASE` nodes prioritize rebroadcasting messages from your other personal nodes. - Use for a stronger or well-positioned attic/roof “base station” node to distribute messages more widely from your own weaker, indoor, or less-well-positioned nodes. - Set one node to `CLIENT_BASE`. Set your other nodes (typically `CLIENT` or `CLIENT_MUTE`) as favorites on the `CLIENT_BASE`. - Perfect for ensuring all your nearby nodes take full advantage of your stronger, well-positioned attic/roof node.
Image: Client Node Example (/img/configuration/client.webp)
*One example of a 'Client' node. Photo credit: Cully@KBOXLABS*
### Avoid `ROUTER`and `REPEATER`
Using `ROUTER` or `REPEATER` roles unnecessarily can cause serious network issues:
- Increased risk of packet collision.
- Reduced message delivery rates.
- Decreased effective network range due to unnecessary hop consumption.
These roles are for very specific applications. Before changing from `CLIENT`, carefully review the documentation (/docs/configuration/radio/device#roles) to understand the implications. Additionally, coordinating this with your local community to ensure its impact is a positive one rather than a negative one.
Remember: A network of `CLIENT` nodes with a small number of well-placed `ROUTERS` is usually the most efficient and stable configuration.
Image: Router Node Example (/img/configuration/router.webp)
*One example of a 'Router' node. Photo credit: Cully@KBOXLABS*


## (Not) Sharing Your Location
Telemetry is shared over your PRIMARY channel (/docs/configuration/radio/channels#role). This means that if your node has acquired GPS coordinates from an integrated GPS chip, or from your mobile device, your coordinates will be sent to the mesh over this channel, using its defined encryption (if any).
By default the PRIMARY channel's name is LongFast with the encryption key "AQ==" (Base64 equivalent of Hex 0x01). If this is left unchanged, your location will be shared with all nodes in range that are also using the default channel.
### Using Position Precision
Meshtastic now supports the ability to control the precision of location data sent over a particular channel.
The `position_precision` setting allows control of the level of precision for location data that is sent over a particular channel. This can be useful for privacy reasons, where obfuscating the exact location may be desired when sending position data over certain channels.
For detailed information on position precision settings and how to configure them, please refer to the Position Precision documentation (/docs/configuration/radio/channels/#position-precision).
### Sharing Location on a Private Secondary Channel
> This is a newer feature that only works for firmware 2.7.1+
To share your location on a private secondary channel while keeping the default primary channel unencrypted, follow these steps:
1. Disable location sharing on the primary channel (Channel 0) to prevent broadcasting your position to all users.
2. Select a secondary channel where you want to share your location. Enable position sharing and choose your desired precision level.
3. Understand automatic location updates: - Only one channel receives your automatic, live location updates. - This is the lowest-indexed secondary channel (excluding Channel 0) with location sharing enabled. - If multiple secondary channels have location sharing enabled, only the one with the lowest index will receive automatic position broadcasts. - Channels with location sharing enabled but not receiving automatic broadcasts can still be used for manual position requests.
#### Example Scenario
Imagine you’re in the following channels:
- Channel 0: “Everyone” (location OFF)
- Channel 1: “CampChat” (location ON)
- Channel 2: “Friends” (location ON)
- Channel 3: “TutuTuesdayGroup” (location OFF)
##### How It Works
- CampChat (Channel 1) receives your live, automatic location updates because it’s the lowest-indexed channel with location sharing enabled.
- Friends (Channel 2) can request your location manually, but it won’t receive automatic updates.
- TutuTuesdayGroup (Channel 3) allows chatting but does not share or receive location data.


## Rebroadcast "Public" Traffic
Meshtastic nodes will rebroadcast all packets if they share LoRa modem settings (/docs/configuration/radio/lora#lora-config-values), regardless of encryption (unless Rebroadcast mode (/docs/configuration/radio/device#rebroadcast-mode) is set to `LOCAL_ONLY`).
If you would like your nodes to include/expand the "public" mesh, you must use the default modem preset (/docs/configuration/radio/lora#modem-preset) `LONG_FAST`. If you change your PRIMARY channel name, you must manually set the LoRa channel to the default for your region (see above).
### Hop Count
It is **strongly** recommended to leave your MAX HOPS (/docs/configuration/radio/lora#max-hops) set to 3 unless you're sure you need more (or less) to reach your destination node. Unnecessarily high hop counts often lead to network issues. If you need to increase the hop count, apply changes only to nodes at the network’s edges, not those near the middle.
Image: Hop Count Image (/img/configuration/max-hops.webp)


## Chat Channels and LoRa Frequency Slots
Previously, Meshtastic used the word "channels" to define two different configuration properties: Messaging Channels & LoRa Channel Numbers. However, this could lead to confusion since "channels" was being used to refer to two distinct concepts. To clarify the distinction, the decision was made to change "LoRa Channel Number" to "LoRa Frequency Slot".
### Radio Config: Channels
These configure "message groups" and include your PRIMARY and SECONDARY channels. All SECONDARY channels use the same LoRa modem config as your PRIMARY channel (including LoRa frequency slot).
There are 8 total messaging channels. Channel 0 is your PRIMARY channel, with channels 1-7 available for private group messaging and/or special channels such as `admin` (/docs/configuration/remote-admin).
### Radio Config: LoRa Frequency Slot
This property, formerly known as "LoRa Channel Number", configures the frequency the radio is set to. Check out the frequency calculator (/docs/overview/radio-settings#frequency-slot-calculator) to view the relationship between "frequency slot" and radio frequency.


## Best Practices
- If you are part of a large mesh and don't know what a setting does, don't change it (unless you're super curious).
- TEST your settings and hardware before you install in hard-to-reach locations.
- Connecting a node to the public MQTT server (/docs/configuration/module/mqtt#connect-to-the-default-public-server) may publish the locations of all nodes in your mesh to the internet.



## Configuration / Region By Country

This table provides a summary of LoRa regions used for each country.
If you'd like to contribute information for your country, click the "Edit this page" link at the bottom.
### A
| Country | LoRa Region | Regulatory document |
| --------- | ------------------ | ---------------------------------------------------------------------------------------------------------- |
| Albania | EU_868 EU_433 | |
| Argentina | ANZ | Spectrum in Argentina (https://www.enacom.gob.ar/bandas-de-uso-compartido-sin-autorizacion_p680) |
| Australia | ANZ | IoT Spectrum in Australia (https://www.iot.org.au/wp/wp-content/uploads/2016/12/IoTSpectrumFactSheet.pdf) |
| Austria | EU_868 EU_433 | |
### B
| Country | LoRa Region | Regulatory document |
| ------------------ | ------------------ | --------------------------------------------------------------------------------------------------- |
| Belgium | EU_868 EU_433 | |
| Bosnia-Herzegowina | EU_868 EU_433 | |
| Brazil | ANZ | Brazilian Regulations (https://www.gov.br/anatel/pt-br/regulado/radiofrequencia/radiacao-restrita) |
| Bulgaria | EU_868 EU_433 | |
### C
| Country | LoRa Region | Regulatory document |
| -------------- | ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| Canada | US | LoRaWAN Regional Parameters (https://www.thethingsnetwork.org/docs/lorawan/regional-parameters/) |
| China | CN | LoRaWAN Regional Parameters (https://lora-alliance.org/wp-content/uploads/2020/11/lorawan_regional_parameters_v1.0.3reva_0.pdf) |
| Chile | ANZ | Chilean RF Regulation (https://www.bcn.cl/leychile/navegar?idNorma=1109333) |
| Croatia | EU_868 EU_433 | |
| Cyprus | EU_868 EU_433 | |
| Czech Republic | EU_868 EU_433 | |
### D
| Country | LoRa Region | Regulatory document |
| ------- | ------------------ | --------------------------------------------------------------------- |
| Denmark | EU_868 EU_433 | Danish Regulations (https://www.retsinformation.dk/eli/lta/2024/490) |
### E
| Country | LoRa Region | Regulatory document |
| ------- | ------------------ | ------------------- |
| Estonia | EU_868 EU_433 | |
### F
... (section truncated for brevity)

## Hardware / Antennas / Index


## Community Favorites
These antennas have garnered positive feedback and frequent recommendations within our community. However, we encourage you to conduct your own research to ensure the best choice for your needs. We are not responsible for individual experiences or results.
### Compact / Handheld
| Frequency | Model | Purchase Links |
|:----------:|:-----------------------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| 915 or 868 | GIZONT 17cm | muzi ᴡᴏʀᴋꜱ (https://muzi.works/products/whip-antenna-17cm) AliExpress (https://www.aliexpress.us/item/3256804421300249.html) |
| 915 | LINX ANT-916-CW-HW-SMA | Mouser (https://www.mouser.com/ProductDetail/TE-Connectivity-Linx-Technologies/ANT-916-CW-HW-SMA?qs=PKuFCuYbGOfeZQiEfd4fWA%3D%3D) DigiKey (https://www.digikey.com/en/products/detail/te-connectivity-linx/ANT-916-CW-HW-SMA/2694126) |
| 915 | ZIISOR TX915-JKS-20 | eBay (https://www.ebay.com/itm/154891841854) |
| 915 | CDEBYTE TX915-JKD-20 (5-pack) | AliExpress (https://www.aliexpress.us/item/3256803106771365.html) |
| 915 | Rabbit Labs / ZIISOR | Amazon US (https://www.amazon.com/gp/product/B0D19JJBKZ) |
| 433 | Rabbit Labs / ZIISOR | Amazon US (https://www.amazon.com/dp/B0D1MSPVQ5) |
| 906 | Smiley 906 Slimline | Smiley Antenna (https://www.smileyantenna.com/shop/meshstatic-system-antennas) |
### Base Station / Repeater
| Frequency | Model | Purchase Links |
|:---------:|:-------------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| 915 | Alfa AOA-915-5ACM | Rokland (https://store.rokland.com/products/alfa-aoa-915-5acm-5-dbi-omni-outdoor-915mhz-802-11ah-mini-antenna-for-lora-halow-application) |
| 915 | Rokland 32" 5.8 dBi | Rokland (https://store.rokland.com/collections/802-11ah-wi-fi-halow/products/5-8-dbi-n-male-omni-outdoor-915-mhz-antenna-large-profile-32-height-for-helium-rak-miner-2-nebra-indoor-bobcat) |
| 868 | MikroTik 868 Omni 6.5dBi | MikroTik (https://mikrotik.com/product/868_omni_antenna) |
### Automotive
| Frequency | Model | Purchase Links |
|:---------:|:------------------:|:------------------------------------------------------------------------------------------:|
| 915 | Laird MA9-5N | DigiKey (https://www.digikey.com/en/products/detail/te-connectivity-laird/MA9-5N/3486940) |
| 915 | Taoglas TI.16.5F11 | DigiKey (https://www.digikey.com/en/products/detail/taoglas-limited/TI-16-5F11/3724558) |



## Important considerations
### What transmission frequency are you using?
Devices on another frequency will not be able to interact with yours. See this listing by The Things Network (https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html) for frequencies licensed for specific countries.
### How will you be carrying / transporting the radio?
A large directional antenna will transmit over significantly greater distance than an omni-directional antenna. However, it must be pointed at its target - so it is not optimal for mobile use.
A tuned half-wave whip antenna may have more omni-directional range than the quarter wave stubby; but it will be conspicuous in your pocket.
Many antennas, especially quarter wave stubby antennas, require the use of ground planes to transmit at peak performance.
### Do you want transmission in all directions?
While humans (mostly water) don't attenuate signal greatly (at LoRa frequencies), buildings & walls do. If your antenna is permanently positioned against a building, signal transmitted towards the wall will be largely lost or attenuated.
### Does my Meshtastic device have the right power range, impedance, and connector for the antenna?
For the LoRa devices, it should be 50 Ohm impedance with SMA connector. Many antennas will be recommended for LoRa use in their technical details.
In contrast, a close range, contact-less Personal Area Network antenna, or a huge antenna at the end of length of coax designed for a 100W transmitter, are not going to be operable.
### Cost, quality, and supply service?
The perfect antenna on paper, sourced from the other side of the world with mixed reviews, doesn't compare to a local supplier who has spent time carefully collating all of the antenna data-sheets for comparison _and_ holds stock immediately available. Personally, I prefer to pay significantly more for a time saving, quality service.
### How close will the antenna be to my Meshtastic device?
Most cables will significantly degrade the signal strength over any significant distance. It is often more effective to place a node outside than to have it indoors with the antenna outside. The exception might be if there is extreme heat, cold, or humidity, and if the shortest possible low loss cable is used.
Still, a proper enclosure should mitigate bad weather.


## Range Testing
As mentioned, while stating the obvious, the simplest way of performing a test is:
- Walk around with a radio sending messages,
- For each message, note location and whether 'ACK' ticks are received,
- Also, note reported signal strengths,
- Change aerials, repeat, and evaluate results.
The range test module (/docs/configuration/module/range-test) has been designed for exactly this purpose. It allows one node to transmit a frequent message, and another node to record which messages were received. This data is saved and can be imported to applications such as Google Earth.
On the topic of testing - performing your own testing and providing feedback is the lifeblood of Meshtastic and open source projects.


## Signal Strength Testing
Real world testing is also discussed by Andreas Spiess (the 'guy with the Swiss accent') in his tutorial (https://www.youtube.com/watch?v=J3PBL9oLPX8). He has written code (https://github.com/SensorsIot/Antenna-Tester) for testing antennas using two Lora32 V1 boards to compare how different antennas behave. Lilygo have also made code available for testing the RSSI on the LORA32 (https://github.com/LilyGO/TTGO-LORA32) boards (https://github.com/Xinyuan-LilyGO/TTGO-LoRa-Series) and the T-Beam (https://github.com/LilyGO/TTGO-T-Beam).
Here are a couple (https://medium.com/home-wireless/testing-lora-antennas-at-915mhz-6d6b41ac8f1d) of excellent (https://medium.com/home-wireless/testing-and-reviewing-lora-antennas-5b37dfa594a3) aerial comparisons. Their utility goes beyond the specific aerials tested, giving insight into:
- Aerial types & their characteristics,
- Testing approaches.


## Hardware / Devices / Index


## Supported Devices
Meshtastic firmware can be installed on a wide range of development boards. The list below provides a brief comparison of currently supported hardware.
### Which board should I choose?
While all the boards listed on this page will run Meshtastic and mesh with each other, some current community favorites are:
- RAK Meshtastic Start Kit: RAK19007 (/docs/hardware/devices/rak-wireless/wisblock/base-board/?rakbase=RAK19007)+RAK4631 (/docs/hardware/devices/rak-wireless/wisblock/core-module/?rakcore=RAK4631)
- Seeed Card Tracker T1000-E (/docs/hardware/devices/seeed-studio/sensecap/card-tracker)
- Seeed Wio Tracker L1 (./seeed-studio/wio-series/tracker-l1)
- Heltec Mesh Node T114 (/docs/hardware/devices/heltec-automation/mesh-node/)
- Nano G2 Ultra (/docs/hardware/devices/b-and-q-consulting/nano/?nano-series=g2)
- Station G2 (/docs/hardware/devices/b-and-q-consulting/station-series/?station-series=g2)
- LILYGO LoRa T3-S3 (/docs/hardware/devices/lilygo/lora/?t-lora=S3-v1)
Please do your research and choose the board that meets your needs (or maybe already have in a bin somewhere).
- We **strongly** recommend choosing devices equipped with the newer Semtech SX126x or LR11xx series, as they offer improved performance and better compatibility than the SX127x series.
- nRF52-based devices use less power than ESP32-based devices and are therefore generally preferred for solar and handset applications.
- ESP32-based devices require more power to operate but are typically lower-cost alternatives that do perform well when using house power, or for handsets that only require a day or two of runtime, and for applications that require WiFi connectivity or more RAM.


## Hardware / Solar Powered / Measure Device Power Consumption

Before you can calculate what size solar panel and battery bank are required you need to determine how much power your device consumes. This is an essential and first step in building a solar powered anything.


## Software / Integrations / Mqtt / Index


## Public MQTT Server
Image: Common MQTT Layout (/img/software/mqtt/mqtt.webp)
The Meshtastic project provides a public MQTT service that users can connect to, with certain restrictions in place to ensure network stability. This service allows Meshtastic devices to bridge over the internet, providing global connectivity for remote networks.
For instructions on connecting to the public MQTT server, please refer to Connect to the Default Public Server (/docs/configuration/module/mqtt/#connect-to-the-default-public-server).
### Restrictions on the Public MQTT Server
To maintain optimal performance and protect LoRa meshes, traffic restrictions are currently applied to the public MQTT server.
#### Zero-Hop Policy
Traffic from the public MQTT server does not fully propagate through local mesh networks. Directly connected nodes will receive the data, but due to the zero-hop policy, it will not spread further to other nodes within the local mesh network.
#### Optimized Traffic Filtering
Only specific portnums are prioritized for transmission over the public MQTT server when using the default PSK:
- NodeinfoApp
- TextMessageCompressedApp
- TextMessageApp
- PositionApp
- TelemetryApp
- MapReportApp
- RoutingApp
#### Location Precision Filtering
On the default PSK, the public server also limits the precision of location data to help protect user privacy. Only position packets containing imprecise location data (10-16 bits) are shared on the topic, ensuring that precise location details are not exposed. For more information on how location precision works, see the Position Precision (https://meshtastic.org/docs/configuration/radio/channels/#position-precision) section.
This filtering focuses network resources on critical traffic, improving overall performance and reducing unnecessary data flow. Since these restrictions are applied at the network level, no firmware updates are required. As Meshtastic networks continue to grow, further traffic reduction measures may become necessary to manage network load and maintain reliable performance across all channels.
### Using Private Brokers
It is not recommended to use the default key (PSK) on a private broker. Doing so potentially allows security vulnerabilities and can flood the mesh with traffic, as private brokers do not enforce the zero-hop policy needed for public channels. Private brokers are intended for use with private channels, where custom PSKs provide secure, isolated communication.


## Software Integrations
Using or emitting packets directly in/from smart home control software such as Home Assistant or other consumers that can work with JSON messages.
When MQTT is enabled, the Meshtastic device simply uplinks and/or downlinks every raw protobuf MeshPacket that it sees to the MQTT broker, encapsulated in a ServiceEnvelope protobuf (https://buf.build/meshtastic/protobufs/docs/main:meshtastic#meshtastic.ServiceEnvelope). In addition, some packet types are serialized or deserialized from/to JSON messages for easier use in consumers. All packets are sent to the broker, whether they originate from another device on the mesh, or the gateway node itself.
### MQTT Topics (https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices)
If no specific root topic (/docs/configuration/module/mqtt#root-topic) is configured, the default root topic will be `msh/REGION`.
For each channel where uplink and/or downlink is enabled, two topics might be used:
#### Protobufs topic
A gateway node will uplink and/or downlink raw (protobuf (https://developers.google.com/protocol-buffers)) MeshPackets to the topic:
`msh/REGION/2/e/CHANNELNAME/USERID`, where `CHANNELNAME` is the name of the channel (firmware versions prior to 2.3.0 will publish to a topic with `/c/` in the place of `/e/`).
For example: `msh/US/2/e/LongFast/!abcd1234`
The payload is a raw protobuf, whose definitions for Meshtastic can be found here (https://github.com/meshtastic/protobufs/blob/master/meshtastic). Reference guides for working with protobufs in several popular programming languages can be found here (https://protobuf.dev/reference/). Looking at the MQTT traffic with a program like `mosquitto_sub` will tell you it's working, but you won't get much useful information out of it. For example:
```text
苓????"! !937bed1cTanksTnk"D???05??=???aP` ShortFast	!937bed1c
```
If encryption_enabled (/docs/configuration/module/mqtt#encryption-enabled) is set to true, the payload of the MeshPacket will remain encrypted with the key for the specified channel.
#### JSON topic
JSON is not supported on the nRF52 platform.
If JSON is enabled (/docs/configuration/module/mqtt#json-enabled), packets from the following port numbers (/docs/development/firmware/portnum) are serialized to JSON: `TEXT_MESSAGE_APP`, `TELEMETRY_APP`, `NODEINFO_APP`, `POSITION_APP`, `WAYPOINT_APP`, `NEIGHBORINFO_APP`, `TRACEROUTE_APP`, `DETECTION_SENSOR_APP`, `PAXCOUNTER_APP` and `REMOTE_HARDWARE_APP`. These are then forwarded to the topic:
`msh/US/2/json/CHANNELNAME/USERID`.
An example of a received `NODEINFO_APP` message:
```json
{ "id": 452664778, "channel": 0, "from": 2130636288, "payload": { "hardware": 10, "id": "!7efeee00", "longname": "base0", "shortname": "BA0" }, "sender": "!7efeee00", "timestamp": 1646832724, "to": -1, "type": "nodeinfo"
}
```
The meaning of these fields is as follows:
- "`id`" is the unique ID for this message.
- "`channel`" is the channel index this message was received on.
- "`from`" is the unique decimal-equivalent Node ID of the node on the mesh that sent this message. (The hexadecimal value `7efeee00` represented by an integer in decimal is `2130636288`).
- "`id`" inside the payload of a `NODEINFO_APP` message is the hexadecimal Node ID (sometimes called User ID) of the node that sent it.
- "`hardware`" is the hardware model (https://github.com/meshtastic/protobufs/blob/master/meshtastic/mesh.proto#L215) of the node sending the `NODEINFO_APP` message.
- "`longname`" is the long name of the device that sent the `NODEINFO_APP` message.
- "`shortname`" is the short name of the device that sent the `NODEINFO_APP` message.
- "`sender`" is the hexadecimal Node ID of the gateway device, which is in this case the same node that sent the `NODEINFO_APP` message.
- "`timestamp`" is the Unix Epoch when the message was received, represented as an integer in decimal.
- "`to`" is the decimal-equivalent Node ID of the destination of the message. In this case, "-1" means it was a broadcast message (this is the decimal integer representation of `0xFFFFFFFF`).
- "`type`" is the type of the message, in this case it was a `NODEINFO_APP` message.
... (section truncated for brevity)

## Examples
- Using mosquitto on a mac (/docs/software/integrations/mqtt/mosquitto.mdx)
- Sending/receiving messages on mosquitto server using python (/docs/software/integrations/mqtt/python.mdx)
- Using MQTT with Node-RED (/docs/software/integrations/mqtt/nodered.mdx)
- Using MQTT with Home Assistant (/docs/software/integrations/mqtt/home-assistant.mdx)
- Using MQTT with Adafruit IO (/docs/software/integrations/mqtt/adafruit-io.mdx)



## Software / Python Cli / Index

The python pip package installs a "meshtastic" command line executable, which displays packets sent over the network as JSON and lets you see serial debugging information from the meshtastic devices. This command is not run inside of python, you run it from your operating system shell prompt directly. If when you type "meshtastic" it doesn't find the command and you are using Windows: Check that the python "scripts" directory is in your path.
For a more complete list of options, run:
```shell
meshtastic --help
```


## Connection Arguments
### --port PORT
The port the Meshtastic device is connected to, i.e. `/dev/ttyUSB0`, `/dev/cu.wchusbserial`, `COM4` etc. if unspecified, meshtastic will try to find it. Important to use when multiple devices are connected to ensure you call the command for the correct device.
This argument can also be specified as `--serial` or `-s`.
```shell title="Usage"
meshtastic --port /dev/ttyUSB0 --info
meshtastic --port COM4 --info
meshtastic -s --info
```
### --host HOST
The hostname/ipaddr of the device to connect to (over TCP). If a host is not provided, the CLI will try to connect to `localhost`.
This argument can also be specified as `--tcp` or `-t`.
```shell title="Usage"
meshtastic --host meshtastic.local --info
meshtastic --host --info
```
### --ble BLE
Connect to a Meshtastic device using its BLE address or name. This option allows for wireless communication with the device, similar to how the `--host` option is used for TCP connections. If an address is not provided, meshtastic will try to find a compatible device that's paired.
This argument can also be specified as `-b`.
```shell title="Usage"
meshtastic --ble "device_name_or_address" --info
meshtastic -b --info
```


## Help & Support Arguments
### -h or --help
Shows a help message that describes the arguments.
```shell title="Usage"
meshtastic -h
```
### --version
Show program's version number and exit.
```shell title="Usage"
meshtastic --version
```
### --support
Print out info that would be helpful supporting any issues.
```shell title="Usage"
meshtastic --support
```


## Optional Arguments
### --export-config
Export the configuration of the device. (to be consumed by the '--configure' command).
To create to a file with the connected device's configuration, this command's output must be piped to a yaml file.
```shell title="Usage"
meshtastic --export-config > example_config.yaml
```
### --configure
Configure radio using a yaml file.
```shell title="Usage"
meshtastic --configure example_config.yaml
```
### --seriallog SERIALLOG
Logs device serial output to either 'stdout', 'none' or a filename to append to. Defaults to 'stdout' if no filename is specified.
```shell title="Usage"
meshtastic --port /dev/ttyUSB0 --seriallog
meshtastic -t meshtastic.local --seriallog log.txt
```
### --info
Read and display the radio config information.
```shell title="Usage"
meshtastic --port /dev/ttyUSB0 --info
```
### --set-canned-message
Set the canned message plugin messages separated by pipes `|` (up to 200 characters).
```shell title="Usage"
meshtastic --set-canned-message "I need an alpinist!|Call Me|Roger Roger|Keep Calm|On my way"
```
### --get-canned-message
Show the canned message plugin message.
```shell title="Usage"
meshtastic --get-canned-message
```
### --set-ringtone RINGTONE
Set the Notification Ringtone (up to 230 characters).
```shell title="Usage"
meshtastic --set-ringtone "LeisureSuit:d=16,o=6,b=56:f.5,f#.5,g.5,g#5,32a#5,f5,g#.5,a#.5,32f5,g#5,32a#5,g#5,8c#.,a#5,32c#,a5,a#.5,c#.,32a5,a#5,32c#,d#,8e,c#.,f.,f.,f.,f.,f,32e,d#,8d,a#.5,e,32f,e,32f,c#,d#.,c#"
```
... (section truncated for brevity)
